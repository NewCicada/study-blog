# [JS垃圾回收](https://juejin.cn/post/6981588276356317214#heading-19)

## 什么是垃圾回收机制（GC）？

在程序运行时会产生很多垃圾，会产生很多垃圾。这些垃圾是程序不用的内存或者之前用过了，后面不用了的内存空间。

垃圾回收就是把这些空间进行回收。

## 垃圾如何产生的？

我们代码在创建一个基础类型，对象，函数等都是要消耗内存的。

例如：
``` ts
let test = {
  name: "isboyjc"
};
test = [1,2,3,4,5]
```
我们知道 JavaScript 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用。

所以，JavaScript 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。

可以简单理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的。

那上面代码首先我们声明了一个变量 test，它引用了对象 {name: 'isboyjc'}，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，

那么之前的对象引用关系就没有了

![image](https://user-images.githubusercontent.com/72189350/219935541-25001ba4-b25b-458c-8949-351506682d7d.png)

GC就是来处理这种情况的。

## 常用的垃圾回收方法有哪些？

一般的垃圾回收方法有两种。

- 标记清除法
- 引用计数法

### 标记清除法

这个方法就是给每个变量都挂载标记，在变量在进入执行环境时，通过反转一个二进制字符来标记或者维护一个进入环境变量和离开环境变量两个列表来标记，反正就是对变量进行标记。

当要清除时，遍历内存中的全部对象，把没有标记的变量全部删掉，在把之前标记的变量给变回原样。

### 标记清除法的优劣点？

优点：非常简单方便，只需要标记即可。

缺点：

标记清除法有一个很大的缺点，就是在清除完内存后，剩余对象的空间是不变的，这样会导致空闲内容不连续，产生内存碎片。

![image](https://user-images.githubusercontent.com/72189350/219936226-7ebf7dbe-5580-4b68-9db9-5eef47fcffc8.png)

对应这样的情况，当我们要把一个`size`大小的块进行分配时，一般采用`First-fit`策略，就是遍历内存，找到一个大于等于`size`的内存空间就返回。

- 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块

- 分配速度慢，因为即便是使用 `First-fit` 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢

### 引用计数法

引用标记法就是跟踪每个变量被使用的次数，当声明一个变量并且引用该变量后，次数就+1，如果这个变量又被赋给另个变量，次数也+1，如果该变量的值被其它值覆盖了，就-1。

就是通过这样的策略，当值为0时，说明变量没有被引用，则由垃圾回收机制回收该内存。

```ts
let a = new Object() 	// 此对象的引用计数为 1（a引用）
let b = a 		// 此对象的引用计数是 2（a,b引用）
a = null  		// 此对象的引用计数为 1（b引用）
b = null 	 	// 此对象的引用计数为 0（无引用）
...			// GC 回收此对象
```

但是引用计数这种算法有个缺陷，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子
```ts
function test(){
  let A = new Object()
  let B = new Object()
  
  A.b = B
  B.a = A
}
```

像上面的例子，这样两个变量都不会变内存释放。

### 引用计数法的优劣点？

优点：引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾，而标记法就只能每隔一段时间清除。

缺点：它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题

## V8对垃圾回收的优化？

V8对垃圾回收进行了一个优化，具体有：

- 分代式垃圾回收
- 并行回收
- 增量标记与懒性清理
- 并发回收

### 分代式垃圾回收

这个并不是一个新的算法，而是在前面的垃圾回收机制上进行优化的，通过把内存活跃度分成老，新两类。

![image](https://user-images.githubusercontent.com/72189350/219937435-08d9f37d-ae00-4abc-bceb-1b019905a80b.png)


#### 老生代

对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，一般采用标记清除法来进行垃圾回收。

#### 新生代

新生代对象，主要采用了一种复制式的方法即 Cheney算法。

Cheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区

![image](https://user-images.githubusercontent.com/72189350/219937479-2be90752-e72a-4b55-99b3-3202793828bb.png)

新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作

当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区。

当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理。

### 并行回收

在介绍并行回收时，我们需要知道一个概念`全停顿`，我们都知道JS是一门单线程语言，在进行垃圾回收时，就会阻塞JS的运行。

等垃圾回收完成后，才会继续执行JS代码，这个就是`全停顿`。

而并行回收，就是在进行垃圾回收的时候，同时开多个辅助线程协助主线程进行垃圾回收，加速垃圾回收的速度。

![image](https://user-images.githubusercontent.com/72189350/219937753-28c94639-cb68-43cf-a067-9274cc667110.png)

### 增量标记与懒性清理

**增量标记**

增量标记就是把我们的全停顿GC过程，给拆解成很多小步，穿插到js运行到过程中，交替多次后完成。

<img width="736" alt="屏幕快照 2023-03-13 下午4 46 43" src="https://user-images.githubusercontent.com/72189350/224651077-2f3a99e7-5a21-4d3f-87dd-391af09246c2.png">

但是这样的方法会给标记过程带来很多的麻烦，比如当我们内存中的数据被标记了后，又在后面的js引用到了那应该怎么办？

这时候就用到了一种方法——**三色标记法**

在上面中，我们用标记法只是简单把数据分为两类，一类为标记，一类为未标记。

三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑

- 白色指的是未被标记的对象
- 灰色指自身被标记，成员变量（该对象的引用对象）未被标记
- 黑色指自身和成员变量皆被标记

<img width="729" alt="image" src="https://user-images.githubusercontent.com/72189350/224652497-824d4c88-1dc1-440f-8c9c-614d9cdb3c44.png">

举个例子，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时

将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色

就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收。

**懒性清理**

当增量标记完成后，如果内存空间足够，就可以将清理过程稍微延迟一下，让 JS 脚本代码先执行，然后在按需逐一进行清理直到所有的非活动对象内存

增量标记和懒性清理可以大大降低主线程的阻塞时间，但是由于分成了多份，会导致总的暂停时间增加，增量标记也会降低应用程序的吞吐量



